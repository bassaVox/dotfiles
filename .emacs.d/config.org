#+TITLE: Emacs configuration
#+AUTHOR: bassavox

#+OPTION: num:nil
#+PROPERTY: header-args :results silent

* Prelude
  There are a couple of resources that can help you using org-mode to configure
  emacs:

  - [[https://www.youtube.com/channel/UCDEtZ7AKmwS0_GNJog01D2g/playlists][renzix]]
  - [[https://github.com/alhassy/emacs.d][A Life Configuring Emacs]] ->  [[http://alhassy.com/emacs.d/index.html][pretty version]]
  - [[https://www.youtube.com/channel/UCDEtZ7AKmwS0_GNJog01D2g/playlists][Youtube "Uncle Bob" playlist]]
  - [[https://www.youtube.com/watch?v=74zOY-vgkyw&list=PLEoMzSkcN8oPH1au7H6B7bBJ4ZO7BXjSZ&index=1][System Crafter's 'Emacs from Scratch']]

* Setup
  Setting repositories and usepackage
** setup repositories

   Melpa and Elpa enabling

   #+BEGIN_SRC emacs-lisp
     (setq package-enable-at-startup nil
           package-archives '(("nongnu" . "https://elpa.nongnu.org/nongnu/")
                              ("elpa" . "https://elpa.gnu.org/packages/")
                              ("melpa" . "https://melpa.org/packages/")
                              ("melpa-stable" . "https://stable.melpa.org/packages/")
                              ("org" . "https://orgmode.org/elpa/")
                              ))

     ;; (package-initialize)
     (unless package-archive-contents
       (package-refresh-contents))
   #+END_SRC   

** bootstratp usepackage

   #+name: use-package
   #+BEGIN_SRC emacs-lisp
     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))
     (require 'use-package)
     (require 'use-package-ensure)
     (setq use-package-always-ensure t) ;; so you don't need to invoke ':ensure t' for every package
   #+END_SRC 

** preferences
*** Display & Appearance
**** Stripping things out
    Removing upper bar and scroll and giving some customized breathing room on all frames:

    #+NAME: bar-disable
    #+BEGIN_SRC emacs-lisp
      (menu-bar-mode -1)
      (scroll-bar-mode -1)
      (tool-bar-mode -1)
      (set-fringe-mode 5)
    #+END_SRC
**** Theme and modeline
    Doom-Moonlight, Doom-Gruvbox, Doom-vibrant and Doom-Tomorrownight,
    doom-horizon, doom-palenight are amongst my favourites themes!
    #+NAME: theme
    #+BEGIN_SRC emacs-lisp
      (use-package doom-themes
        :config (load-theme 'doom-palenight t)
        (doom-themes-org-config)
        )
    #+END_SRC 
    
    Doom has a nice, minimalistic, modeline. You may have to run "all-the-icons-install-fonts".
    #+NAME: modeline
    #+BEGIN_SRC emacs-lisp
      ;; all-the-icons is required for doom-modeline
      (use-package all-the-icons)
      (use-package doom-modeline
        :ensure t
        :init (doom-modeline-mode 1)
        :config
        (set-face-attribute 'mode-line nil :family "Noto Sans" :height 80)
        (set-face-attribute 'mode-line-inactive nil :family "Noto Sans" :height 80)
        :custom ((doom-modeline-height 1)))
      (column-number-mode)


    #+END_SRC
**** Cursor and Movement
    By default, emacs' jumps the cursor, along with the content, 
    to the middle of the screen when scrolling pass the end of the file.
    To prevent those jumps use:

    #+BEGIN_SRC emacs-lisp
      (setq scroll-conservatively 101 )
    #+END_SRC

    Highlighting current line and making it more pronounceable when
    changing windows or buffers.

    #+BEGIN_SRC emacs-lisp
      (when window-system (global-hl-line-mode t))
      (use-package beacon
        :ensure t
        :init
        (beacon-mode 1))

    #+END_SRC
*** Fonts
    My go-to fonts are "Source Code Pro", [[https://www.jetbrains.com/lp/mono/]["JetBrains Mono"]], "Fira Code Retina" and "Ubuntu Mono"
    and I my change between them from time to time. I haven't set ligatures yet, but I really don't
    mind much about that for now.
    #+NAME:fonts
    #+BEGIN_SRC emacs-lisp
      (set-face-attribute 'default nil :font "Fira Code Retina" :height 107)
    #+END_SRC
    
*** Miscelania

    Just use y and n for prompt action. 
    Preventing the "error sound", for example, when reaching the end of the
    file.

    #+NAME: minor-miscelania
    #+BEGIN_SRC emacs-lisp
      (defalias 'yes-or-no-p 'y-or-n-p)
      (setq ring-bell-function 'ignore)
    #+END_SRC
    
    
    Changing default behavior of saving backups on the same directory
    to a dedicated folder
    #+NAME: backups
    #+BEGIN_SRC emacs-lisp
      (setq backup-directory-alist `(("." . "~/.backup_emacs"))
            backup-by-copying t
            delete-old-versions t
            kept-new-versions 10
            kept-old-versions 10
            version-control t
            auto-save-list-file-prefix nil
            auto-save-default nil)
    #+END_SRC

    Disabling the Welcome screen
    #+BEGIN_SRC emacs-lisp
    (setq inhibit-startup-screen t)
    
    #+END_SRC

*** prettify
You can enable displaying unicode versions of math operators (e.g. LaTeX) or other symbols
(like rust's -> return type signature) using **prettify-symbols-mode**
* Terminal
#+BEGIN_SRC emacs-lisp
  (defvar my-term-shell "/bin/bash")
  (defadvice ansi-term (before force-bash)
    (interactive (list my-term-shell)))
  (ad-activate 'ansi-term)
#+END_SRC
* General Use Packages
** which-key
   Shows keybindings as you type

   #+NAME: which-key
   #+BEGIN_SRC emacs-lisp
     (use-package which-key
       :init (which-key-mode)
       :diminish which-key-mode
       :config
       (setq which-key-idle-delay 0.8))
   #+END_SRC
** magit
   Modeline information about branches is not always [[https://magit.vc/manual/magit/The-mode_002dline-information-isn_0027t-always-up_002dto_002ddate.html][up-to-date]],
   you can force upate from 'vc' package with (setq auto-revert-check-vc-info t)
   with some performance penalty
   #+NAME: magit
   #+BEGIN_SRC emacs-lisp
     (use-package magit)
   #+END_SRC
   
** helm

   Other file completions are ido-mode and ivy 

   #+NAME: helm
   #+BEGIN_SRC emacs-lisp
     (use-package helm
       :init
       (setq helm-follow-mode-persistent t
	     helm-autoresize-max-height 40
	     helm-display-header-line nil)
       :config
       ;(require 'helm-config)
       (helm-autoresize-mode t)
       (add-hook 'helm-minibuffer-set-up-hook 'helm-hide-minibuffer-maybe)
       (helm-mode t))
     #+END_SRC
*** helm-rg
#+NAME: helm-rg
#+BEGIN_SRC emacs-lisp
(use-package helm-rg)

#+END_SRC
*** helm-bibtex
   #+begin_src emacs-lisp
     ;; Change fields and format
     (setq bibtex-user-optional-fields '(("keywords" "Keywords to describe the entry" "")
                                         ("file" "Link to document file." ":"))
           bibtex-align-at-equal-sign t)

     (setq bib-files-directory (directory-files
                                (concat (getenv "HOME") "/git/org/bibliography/") t
                                "^[A-Z|a-z].+.bib$")
           pdf-files-directory (concat (getenv "HOME") "/Dropbox/pdf/"))

   #+end_src

    
    #+begin_src emacs-lisp
      (use-package helm-bibtex
        :config
        (setq bibtex-completion-bibliography bib-files-directory
              bibtex-completion-library-path pdf-files-directory
              bibtex-completion-pdf-field "file"
              bibtex-completion-notes-path org-directory))
    #+end_src
** projectile
   Projectile manages projects.

   #+NAME: projectile
   #+BEGIN_SRC emacs-lisp
     (use-package helm-projectile
       :config
       (projectile-mode t)
       (helm-projectile-on))

   #+END_SRC
*** projectile-hydra

My initial inspiration was [[https://github.com/abo-abo/hydra/wiki/Projectile][this example.]]

#+NAME: hydra-projectile
#+begin_src emacs-lisp
(defhydra hydra-projectile-other-window (:color teal)
  "projectile-other-window"
  ("f"  projectile-find-file-other-window        "file")
  ("g"  projectile-find-file-dwim-other-window   "file dwim")
  ("d"  projectile-find-dir-other-window         "dir")
  ("b"  projectile-switch-to-buffer-other-window "buffer")
  ("q"  nil                                      "cancel" :color blue))

(defhydra hydra-projectile (:color teal
                            :hint nil)
  "
     PROJECTILE: %(projectile-project-root)

     Find File            Search/Tags          Buffers                Cache
------------------------------------------------------------------------------------------
_s-f_: file            _r_: ripgrep           _i_: Ibuffer           _c_: cache clear
 _ff_: file dwim       _g_: update gtags      _b_: switch to buffer  _x_: remove known project
 _fd_: file curr dir   _o_: multi-occur     _s-k_: Kill all buffers  _X_: cleanup non-existing
  _d_: dir                                                       ^^^^_z_: cache current
  

"
  ("r"   helm-projectile-rg)
  ("b"   projectile-switch-to-buffer)
  ("c"   projectile-invalidate-cache)
  ("d"   projectile-find-dir)
  ("s-f" projectile-find-file)
  ("ff"  projectile-find-file-dwim)
  ("fd"  projectile-find-file-in-directory)
  ("g"   ggtags-update-tags)
  ("s-g" ggtags-update-tags)
  ("i"   projectile-ibuffer)
  ("K"   projectile-kill-buffers)
  ("s-k" projectile-kill-buffers)
  ("m"   projectile-multi-occur)
  ("o"   projectile-multi-occur)
  ("s-p" projectile-switch-project "switch project")
  ("p"   projectile-switch-project)
  ("s"   projectile-switch-project)
  ("x"   projectile-remove-known-project)
  ("X"   projectile-cleanup-known-projects)
  ("z"   projectile-cache-current-file)
  ("`"   hydra-projectile-other-window/body "other window")
  ("q"   nil "cancel" :color blue))

#+end_src
** company
   
   Autocomplete for words in programming languages. It needs lsp-mode
   
   #+NAME: company
   #+BEGIN_SRC emacs-lisp
     (use-package company
       :config
       (add-hook 'after-init-hook 'global-company-mode)
       (setq company-require-match 'never
	     company-minimum-prefix-length 2
	     company-tooltip-align-annotation 1
	     company-idle-delay 1
	     company-tooltip-limit 20
	     global-company-mode t))
   #+END_SRC

** lsp-mode
   Needed by company. Provides IDE-like experience. TODO: integrate with python
   See [[https://emacs-lsp.github.io/lsp-mode/page/lsp-pyls/][python support.]] See [[https://github.com/mattduck/dotfiles/blob/master/emacs.d.symlink/init.org#lsp-base-packages][other's configs]]
   #+NAME: lsp-mode
   #+BEGIN_SRC emacs-lisp
     (use-package lsp-mode
       :commands lsp
       :ensure t
       :hook
       ((scala-mode . lsp)
        (python-mode . lsp)
        (js-mode . lsp)
        (rust-mode . lsp)
        (web-mode . lsp)
        (sh-mode . lsp)
        (vue-mode . lsp))
       :config 
       (setq lsp-prefer-flymake nil
             lsp-enable-snippet t
             lsp-auto-execute-action t
             lsp-eldoc-render-all t
             lsp-enable-completion-at-point t
             lsp-enable-xref t
             lsp-enable-indentation t
             lsp-rust-analyzer-cargo-watch-command "clippy"
             lsp-rust-analyzer-server-display-inlay-hints t
             lsp-rust-analyzer-display-lifetime-elision-hints-enable "skip_trivial"
             lsp-rust-analyzer-display-chaining-hints t
             lsp-rust-analyzer-display-lifetime-elision-hints-use-parameter-names nil
             lsp-rust-analyzer-display-closure-return-type-hints t
             lsp-rust-analyzer-display-parameter-hints nil
             lsp-rust-analyzer-display-reborrow-hints nil

             )
       :bind-keymap
       ("C-?" . lsp-command-map)
       )

     ;; lisp-ui adds inline UI element
     (use-package lsp-ui
       :after lsp-mode
       :custom
       (lsp-ui-peek-always-show t)
       (lsp-ui-sideline-show-hover t)
       (lsp-ui-doc-enable nil)
       (lsp-ui-doc-position "botton")
       :hook (lsp-mode-hook . lsp-ui-mode))

     (use-package company-lsp
       :after '(company lsp-mode)
       :config
       (setq company-lsp-cache-candidates t
             company-lsp-async t
             company-lsp-enable-snippet t)
       (push 'company-lsp company-backends))

     (use-package company-box
       :custom
       (company-idle-delay 0.5)
       :hook (company-mode . company-box-mode)


       )
     (use-package dap-mode
       :config
       (dap-mode 1)
       (dap-ui-mode 1)
       (require 'dap-python))


   #+END_SRC
** flycheck
#+NAME: flyckeck
#+BEGIN_SRC emacs-lisp

  (use-package flycheck
    :ensure t
    :init (global-flycheck-mode))
#+END_SRC
** editorconfig
#+NAME: editorconfig
#+BEGIN_SRC emacs-lisp
   (use-package editorconfig
     :ensure t
     :config
     (editorconfig-mode 1)
     (add-hook 'editorconfig-after-apply-functions
     (lambda (props) (setq web-mode-script-padding 0)))

   )
#+END_SRC
** yasnippet
Copy and paste from [[https://www.reddit.com/r/emacs/comments/9bvawd/use_yasnippet_via_usepackage/][reddit]] user
#+NAME: yasnippet
#+BEGIN_SRC emacs-lisp
   (use-package yasnippet
     :ensure t
     :config
    (yas-reload-all)
    ;; (add-hook 'vue-mode #'yas-minor-mode)
    ;; (add-hook 'web-mode #'yas-minor-mode)
    ;; (add-hook 'python-mode #'yas-minor-mode)
    ;; (add-hook 'rust-mode #'yas-minor-mode)
    (add-hook 'prog-mode-hook 'yas-minor-mode)
    (add-hook 'text-mode-hook 'yas-minor-mode)
    )

   (use-package yasnippet-snippets
     :ensure t)
#+END_SRC
** avy
   Allows you to navegate by character seen on any visible portion of
   any opened window

#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :config
    ;; home row keys
    (setq avy-keys '(?c ?i ?e ?a ?n ?t ?s ?p))
)

#+END_SRC
** dumb-jump
   I've build from source ripgrep (written in rust) beforehand, which this package
   can use to jump to definition

   #+BEGIN_SRC emacs-lisp
     (use-package dumb-jump
       :ensure t)
   #+END_SRC

** rainbow everywhere
#+NAME: rainbow-delimiters
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC
** being helpful
#+NAME: helpful
#+BEGIN_SRC emacs-lisp
  (use-package helpful
    :bind
    ([remap describe-function] . helpful-callable)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . helpful-variable)
    ([remap describe-key] . helpful-key))
#+END_SRC
** flyspell
I need to change its keybidings. They are obtrusive.

   Requires [[https://github.com/hunspell/hunspell][Hunspell]].
   #+begin_src emacs-lisp
     (use-package flyspell
       :config
       (setq ispell-program-name "hunspell"
             ispell-dictionary "pt_BR")
       (define-key flyspell-mode-map (kbd "C-M-i") nil)
       (define-key flyspell-mode-map (kbd "C-,") nil)
       (define-key flyspell-mode-map (kbd "C-.") nil)
       :hook (text-mode . flyspell-mode))
   #+end_src
** smartparens
There's some introductory remarks [[https://ebzzry.com/en/emacs-pairs/][here]] and an example of
using it with hydra [[https://github-wiki-see.page/m/abo-abo/hydra/wiki/Smartparenshere][here]], which seems outdated.

#+NAME: hydra-startparens
#+begin_src emacs-lisp
(defhydra hydra-smartparens (:hint nil)
  "
 Moving^^^^                       Slurp & Barf^^   Wrapping^^            Sexp juggling^^^^               Destructive
------------------------------------------------------------------------------------------------------------------------
 [_a_] beginning  [_n_] down      [_L_] bw slurp   [_R_]   rewrap        [_-_] split   [_,_] transpose   [_c_] change inner  [_w_] copy
 [_e_] end        [_N_] bw down   [_B_] bw barf    [_u_]   unwrap        [___ ] splice  [_A_] absorb      [_C_] change outer
 [_s_] forward    [_p_] up        [_l_] slurp      [_U_]   bw unwrap     [_r_] raise   [_E_] emit        [_k_] kill          [_g_] quit
 [_t_] backward   [_P_] bw up     [_b_] barf       [_(__{__[_] wrap (){}[]   [_j_] join    [_o_] convolute   [_K_] bw kill       [_q_] quit"
  ;; Moving
  ("a" sp-beginning-of-sexp)
  ("e" sp-end-of-sexp)
  ("s" sp-forward-sexp)
  ("t" sp-backward-sexp)
  ("n" sp-down-sexp)
  ("N" sp-backward-down-sexp)
  ("p" sp-up-sexp)
  ("P" sp-backward-up-sexp)
  
  ;; Slurping & barfing
  ("L" sp-backward-slurp-sexp)
  ("B" sp-backward-barf-sexp)
  ("l" sp-forward-slurp-sexp)
  ("b" sp-forward-barf-sexp)
  
  ;; Wrapping
  ("R" sp-rewrap-sexp)
  ("u" sp-unwrap-sexp)
  ("U" sp-backward-unwrap-sexp)
  ("(" sp-wrap-round)
  ("{" sp-wrap-curly)
  ("[" sp-wrap-square)
  
  ;; Sexp juggling
  ("-" sp-split-sexp)
  ("_" sp-splice-sexp)
  ("r" sp-raise-sexp)
  ("j" sp-join-sexp)
  ("," sp-transpose-sexp)
  ("A" sp-absorb-sexp)
  ("E" sp-emit-sexp)
  ("o" sp-convolute-sexp)
  
  ;; Destructive editing
  ("c" sp-change-inner :exit t)
  ("C" sp-change-enclosing :exit t)
  ("k" sp-kill-sexp)
  ("K" sp-backward-kill-sexp)
  ("w" sp-copy-sexp)

  ("q" nil)
  ("g" nil))

#+end_src
** popper
[[https://karthinks.com/software/dealing-with-window-clutter-in-emacs/][Stumbled upon]] the popper's author blog. It seems a sane way to manage window to a fro.
#+begin_src emacs-lisp
  (use-package popper
    :ensure t ; or :straight t
  
    :init
    (setq popper-reference-buffers
          '("\\*Messages\\*"
            "Output\\*$"
            "\\*Async Shell Command\\*"
            help-mode
            compilation-mode))
    (popper-mode +1)
    (popper-echo-mode +1))
  (setq popper-group-function #'popper-group-by-directory)
#+end_src

* Emacs batteries included
** mark & kill ring
Using C-u c-SPC enables you to cycle through the kill ring using only C-SPC, see [[info:emacs#Mark Ring][emacs#Mark Ring]].
[[https://www.masteringemacs.org/article/fixing-mark-commands-transient-mark-mode][Some]] prefer to change the behavior of the mark system in respect to the active transient-mark-mode

TODO: get used to global end local mark ring, maybe with: 'helm-all-mark-rings C-x c C-c SPC
#+NAME: mark-repeat
#+begin_src emacs-lisp
  (setq set-mark-command-repeat-pop  t)
#+end_src
** eletric pair mode
See [[info:emacs#Matching][emacs#Matching]]

#+NAME eletric-pair-mode
#+begin_src emacs-lisp
  (electric-pair-mode 1)
#+end_src
** shift selection
I don't see much use in [[info:emacs#Shift Selection][emacs#Shift Selection]]
#+NAME shift-selection-disabling
#+begin_src emacs-lisp
  (setq shift-select-mode nil)
#+end_src
* Org Mode Related
Generally I go to [[http://doc.norang.ca/org-mode.html][a good workflow explanation]] to get ideas on using org mode.
** general org-mode config
#+BEGIN_SRC emacs-lisp
  (use-package org
    :config
    (define-key org-mode-map (kbd "C-,") nil)
    (setq org-agenda-files
          '("~/git/org/"))
    (setq org-todo-keywords
          '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
          (sequence "BACKLOG(b)" "READY(r)" "ACTIVE(a)" "|" "COMPLETED(c)" "CANC(k)" )))
    (setq org-attach-id-dir (concat (getenv "HOME") "/Dropbox/org-attachments"))
    (setq org-directory (concat (getenv "HOME") "/git/org"))
  (setq org-agenda-custom-commands
        '(
          ("n" todo "NEXT")
          ("h" "Agenda and Home-related tasks"
           ((agenda)
            (tags-todo "@home")
            (tags "@home"
                  ((org-agenda-sorting-strategy '(priority-up)))))
           ((org-agenda-sorting-strategy '(priority-down))))
          ("o" "Agenda and Office-related tasks"
           ((agenda)
            (tags-todo "@office")
            (tags "@office")))))

    (setq org-tag-alist
          '((:startgroup . nil)
            ;; mutually exclusive tags of location
            ("@home" . ?h)
            ("@office" . ?o)
            ("@errand" . ?e)
            (:endgroup . nil)
            (:startgroup . nil)
            ;; mutually exclusive tags of action
            ("Cleaning" . ?c)
            ("Thinking" . ?t)
            ("Shopping" . ?s)
            ("Practicing" . ?p)
            (:endgroup . nil)
            ("idea" . ?i)
            ("funny" . ?y)
            ("habit" . ?b)
            ("personal" . ?l)))

    (setq org-refile-targets
          '(("arquivar.org" :maxlevel . 9)))
    ;; saving after refiling
    (advice-add 'org-refile :after 'org-save-all-org-buffers)
    (setq org-capture-templates
      '(("t" "Todo" entry (file+headline "~/git/org/anotar.org" "Inbox")
         "* TODO %?\n  %i\n  %a")
        ("f" "Fleeting Note" entry (file+headline "~/git/org/anotar.org" "Rethink or delete")
         "* %?\n %i\n")
        ("j" "Journal" entry (file+datetree "~/git/org/lembrar.org")
         "* %?\nEntered on %U\n  %i\n  %a")))

    ;; tracking habits
    (require 'org-habit)
    (add-to-list 'org-modules 'org-habit)
    (setq org-habit-graph-column 60)
    (setq org-startup-folded t)
    :custom
    (org-agenda-start-with-log-mode t) ;; present a log intraday when logging
    (org-log-done 'time)
    (org-log-into-drawer t))
#+END_SRC
** hydra-org
A hydra for org inspired by [[https://github.com/abo-abo/hydra/wiki/orgmode][this]]

#+NAME:hydra-global-org
#+begin_src emacs-lisp
  (defhydra hydra-global-org (:color blue)
    "Org"
    ("c" org-capture "Capture") ; Don't forget to define the captures you want http://orgmode.org/manual/Capture.html
    ("i" org-clock-in  "Clock-In") ; used with (org-clock-persistence-insinuate) (setq org-clock-persist t)
    ("o" org-clock-out "Clock-Out") ; you might also want (setq org-log-note-clock-out t)
    ("e" org-clock-goto "Clock Goto") ; global visit the clocked task
    ("u" outline-up-heading "Up heading")
    ("n" org-next-visible-heading "Next Heading" :color red)
    ("t" org-backward-heading-same-level "Backward =Level" :color red)
    ("s" org-forward-heading-same-level "Forward =Level":color red)
    ("p" org-previous-visible-heading "Previous Heading" :color red)
    ("b" org-insert-structure-template "Insert Block")
    )

#+end_src
** org-babel
#+BEGIN_SRC emacs-lisp
; (use-package ein)


#+END_SRC
#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '(
     (python . t)
     ; (ein . t)
     (ipython . t)
     (shell . t)
     (latex . t)
     (scheme . t)
     (R . t)
     (lilypond . t)
     (sql . t)
     (mermaid . t)
     ))
#+END_SRC
** ox-hugo
   Let's try out hugo for static site generation. This package exports org
   subtrees using markdown to the appropriate content folder of a Hugo site.
   Hugo allegedly supports org markdown, but this package is very usefull
   if you plan to use a single file and export posts, for example, by
   subtrees.
#+NAME: ox-hugo
#+BEGIN_SRC emacs-lisp
  (use-package ox-hugo
    :ensure t
    :after ox)
#+END_SRC
** plantuml
   Well, this is not just for Org Mode but I usually make diagrams in it.
#+BEGIN_SRC emacs-lisp
  (use-package plantuml-mode
    :ensure t
    :init
    (setq plantuml-default-exec-mode 'jar)
    (setq plantuml-jar-path "/usr/share/plantuml/plantuml.jar")
    (setq org-plantuml-jar-path (expand-file-name "/usr/share/plantuml/plantuml.jar"))
    (setq org-startup-with-inline-images t)
    (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
    (org-babel-do-load-languages 'org-babel-load-languages '((plantuml .t )))
    :interpreter ("plantuml" . plantuml-mode)
    )
#+END_SRC
** htmlize
#+BEGIN_SRC emacs-lisp
(use-package htmlize)

#+END_SRC
** org-ref
  [[https://www.youtube.com/watch?v=2t925KRBbFc][Youtube intro]] (old), [[https://youtu.be/3u6eTSzHT6s][Youtube intro (new)]]

  #+begin_src emacs-lisp
    (use-package org-ref
      :config
      (setq org-ref-completion-library 'org-ref-helm-cite
            org-ref-get-pdf-filename-function 'org-ref-get-pdf-filename-helm-bibtex
            org-ref-default-bibliography bib-files-directory
            org-ref-notes-directory org-directory
            org-ref-notes-function 'orb-edit-notes))
    (require 'org-ref-helm)
  #+end_src
** ox-reveal
#+begin_src emacs-lisp
      (use-package ox-reveal
        :config
        (setq Org-Reveal-title-slide t))
#+end_src
* Knowledge Management
- A [[https://www.youtube.com/watch?v=EjQRqd_3AnA][good example]].
- [[https://www.orgroam.com/manual.html#Introduction][Org-roam documentation]]
- [[https://youtu.be/Wy9WvF5gWYg][org roam and bibitex]]
  
#+END_SRC
** org-noter
Org noter will open another frame with two windows for you to make annotations, 
this is called a 'annotation session', that can be killed when on document buffer 
by pressing 'q'. Just press 'i' to make an annotation.

Just (M-x org-noter) on a org file with the correct property and you can create
or review your notes on a pdf.

#+NAME: org-noter 
#+BEGIN_SRC emacs-lisp
(use-package org-noter)

#+END_SRC
** org roam
   Following the Zettelkasten method, [[https://www.orgroam.com/manual.html][org roam]] helps bulding a network of permanent
   notes with hyperlinks.
   For the "fleeting notes", notes capture when doing some other activity that are usually
   processed within a day, one can use both org-capture or Org Roam's "Dailies".

   
   To install it, execute first: 
   (use-package org-roam :ensure t)

#+BEGIN_SRC emacs-lisp
  ;;   (use-package org-roam
  ;;     :after org
  ;;     :ensure t
  ;;     :init
  ;;     (setq org-roam-v2-ack t) ; to inhibit message about new version 2
  ;;     :custom
  ;;     (org-roam-directory "~/git/org-roam")
  ;;     (org-roam-completion-everywhere t)
  ;;     (org-roam-capture-templates
  ;;      '(("d" "default" plain
  ;;         "%?"
  ;;         :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
  ;;         :unnarrowed t)))
  ;;     (org-roam-dailies-capture-templates
  ;;      '(("d" "default" entry
  ;;         "* [%<%H:%M>] %?"
  ;;         :if-new (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n")
  ;;         :unarrowed t
  ;; )))
  ;;     :bind
  ;;     (("C-c n f" . org-roam-node-find)
  ;;      ("C-c n g" . org-roam-graph)
  ;;      ("C-c n r" . org-roam-node-random)		    
  ;;      (:map org-mode-map
  ;;            (("C-c n i" . org-roam-node-insert)
  ;;             ("C-c n o" . org-id-get-create)
  ;;             ("C-c n t" . org-roam-tag-add)
  ;;             ("C-c n a" . org-roam-alias-add)
  ;;             ("C-c n l" . org-roam-buffer-toggle))))
  ;;     :bind-keymap
  ;;     ("C-c n d" . org-roam-dailies-map)
  ;;     :config
  ;;     (require 'org-roam-dailies)
  ;;     (org-roam-setup)
  ;;     )
#+END_SRC
*** Usage
    [[https://lucidmanager.org/productivity/taking-notes-with-emacs-org-mode-and-org-roam/][intro]]
    With org-roam completion you can link notes just by typing some of the initial words of it
    on another note and hit C-M-i.

    One can assign a id to any heading inside a Roam's note, creating a subnote (I don't really see
    use cases for this right now, but, anyway, you can do that with *org-id-get-create*

    If you have notes with the same name, you can insert a roam-aliases property on the node:
    *org-roam-alias-add*

    With the Roam buffer you can see the backlinks to that node while visiting it,
    show the buffer using (C-c n l).
** org-bibitex
   #+begin_src emacs-lisp
     ;; (use-package org-roam-bibtex
     ;;   :after (org-roam helm-bibtex)
     ;;   :bind (:map org-mode-map ("C-c n b" . orb-note-actions))
     ;;   :config
     ;;   (require 'org-ref))
     ;;    (org-roam-bibtex-mode)		

   #+end_src
** latex
   Cdlatex provides [[https://orgmode.org/manual/CDLaTeX-mode.html#CDLaTeX-mode][some expansions]], that can be used inside org-mode
   (when on org mode you enable via M-x org-cdlatex-mode)
   
   #+begin_src emacs-lisp
     (use-package tex
       :ensure auctex
       :ensure cdlatex)
     (setq org-latex-pdf-process (list "latexmk -shell-escape -bibtex -f -pdf %f"))
     
   #+end_src
** BibTex
[[https://lucidmanager.org/productivity/emacs-bibtex-mode/][Manage your literature with Emacs BibTex Mode]]

#+begin_src emacs-lisp
(setq bibtex-dialect 'biblatex)
  
#+end_src
** pdf-tools
   There are some [[https://github.com/politza/pdf-tools][dependencies]] to pdf-tools. After installing it you can, for example,
render a pdf in 'midnight mode' which, by itself, justifies you installing it.
(M-x pdf-tools-help RET) will help.

TODO: For some reason, when visiting a PDF file via org-noter, running M-x pdf-tools-install
was required for pdf-tools to load. 
#+BEGIN_SRC emacs-lisp
(use-package pdf-tools)

#+END_SRC
* Presentations, Graphs
** mermaide mode
It too defines a  org-babel-execute:mermaid function, so i put it before ob-mermaid
#+begin_src emacs-lisp
  ;;(use-package mermaid-mode)
#+end_src
** ob-mermaid
#+begin_src emacs-lisp
  (use-package ob-mermaid)

#+end_src
* Languages Specific Modes and Support
** all
#+NAME: all-languages
#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil) 
#+END_SRC
** rust
   See https://www.reddit.com/r/rust/comments/a3da5g/my_entire_emacs_config_for_rust_in_fewer_than_20/


   Another good config: [[https://robert.kra.hn/posts/rust-emacs-setup/][Robert Krahn's]]
   
#+NAME: rust-mode
#+BEGIN_SRC emacs-lisp
     (use-package toml-mode)
     
     (use-package rust-mode
       :hook (rust-mode . lsp))

     ;; Add keybindings for interacting with Cargo
     (use-package cargo
       :hook (rust-mode . cargo-minor-mode))

     (use-package flycheck-rust
       :config (add-hook 'flycheck-mode-hook #'flycheck-rust-setup))
#+END_SRC
*** rustic
#+NAME: rustic
#+begin_src emacs-lisp
  (use-package rustic
    :ensure
    :config
    ;; uncomment for less flashiness
    ;; (setq lsp-eldoc-hook nil)
    ;; (setq lsp-enable-symbol-highlighting nil)
    ;; (setq lsp-signature-auto-activate nil)

    ;; comment to disable rustfmt on save
    (setq rustic-format-on-save t)
    (add-hook 'rustic-mode-hook 'bassavox/rustic-mode-hook))


  (defun bassavox/rustic-mode-hook ()
    ;; so that run C-c C-c C-r works without having to confirm, but don't try to
    ;; save rust buffers that are not file visiting. Once
    ;; https://github.com/brotzeit/rustic/issues/253 has been resolved this should
    ;; no longer be necessary.
    (when buffer-file-name
      (setq-local buffer-save-without-query t)))
#+end_src

** python
Elpy configuration extracted from this [[https://medium.com/analytics-vidhya/managing-a-python-development-environment-in-emacs-43897fd48c6a][medium article]], this is a nice
article and his python configuration is very comprehensive
#+NAME: python-mode
#+BEGIN_SRC emacs-lisp
  ;; (use-package elpy
  ;;   :ensure t
  ;;   :bind
  ;;   (:map elpy-mode-map
  ;; 	("C-M-n" . elpy-nav-forward-block)
  ;; 	("C-M-p" . elpy-nav-backward-block))
  ;;   :hook ((elpy-mode . flycheck-mode)
  ;; 	 (pyenv-mode . elpy-rpc-restart))
  ;;   :init
  ;;   (elpy-enable)
  ;;   :config
  ;;   (setq elpy-modules (delq 'elpy-module-flymake elpy-modules)))

  ;; (use-package elpy
  ;;   :ensure t
  ;;   :init
  ;;   (elpy-enable))
#+END_SRC

#+NAME: blacken-mode
#+BEGIN_SRC emacs-lisp
  (use-package blacken
    :ensure t
    :hook (python-mode . blacken-mode)
    :hook (ein-python . blacken-mode)
    :config
    (setq blacken-line-lenth '88))
#+END_SRC

#+NAME: python-interpreter
#+BEGIN_SRC emacs-lisp
(setq python-shell-interpreter "/usr/bin/python3.9")

#+END_SRC
** sml
  #+NAME: sml-mode
  #+BEGIN_SRC emacs-lisp
  (use-package sml-mode)
  #+END_SRC
** web
   #+NAME: web-mode
   #+BEGIN_SRC emacs-lisp
     (use-package web-mode
     :config
     (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
     (add-to-list 'auto-mode-alist '("\\.vue\\'" . web-mode))


     (setq
     web-mode-markup-indent-offset 2
     web-mode-code-indent-offset 2
     web-mode-enable-auto-closing t
     web-mode-enable-auto-opening t
     web-mode-enable-auto-pairing t
     web-mode-enable-auto-indentation t
     web-mode-script-padding 0
     web-mode-block-padding 0
     web-mode-style-padding 0
     )

     )

     (use-package prettier-js
     :config
     ;; (add-hook 'web-mode-hook 'prettier-js-mode))
     )
     (setq prettier-js-args '(
     "--trailing-comma" "all"
     "--bracket-spacing" "true"
     "--single-quote" "true"
     ))
   #+END_SRC
** vue
   #+NAME: vue-mode
   #+BEGIN_SRC emacs-lisp
     ;; (use-package vue-mode
     ;;   :mode ("\\.vue\\'" . vue-mode)
     ;;   :config
     ;;   (add-hook 'vue-mode-hook #'lsp)
     ;;   )
   #+END_SRC
** racket
#+BEGIN_SRC emacs-lisp
    (use-package racket-mode
      :ensure t
      :init
      (add-to-list 'org-src-lang-modes '("racket" . racket ))
      ;; this won't work....you need og-racket manually installed for integration:
      ;;(org-babel-do-load-languages 'org-babel-load-languages '((racket .t )))
      :interpreter ("racket" . racket-mode)
      )

#+END_SRC

** r
#+BEGIN_SRC emacs-lisp
; (use-package ess)

#+END_SRC
** MIT-scheme
   So you want to read [[https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html][SICP]]...
   Go install scheme with "sudo apt install mit-scheme" on Ubuntu.
#+NAME: giser
#+BEGIN_SRC emacs-lisp
  (use-package geiser)
  (setq geiser-active-implementations '(mit))
#+END_SRC
** clojure
#+BEGIN_SRC emacs-lisp
    (use-package clojure-mode
      :ensure t
      )
#+END_SRC
#+BEGIN_SRC emacs-lisp
  (use-package cider
    :ensure t
    )

  (use-package inf-clojure)

#+END_SRC
** lilypond
   [[https://lilypond.org/doc/v2.23/Documentation/usage/text-editor-support.html][Lilypond on emacs]] needs some elisp files found on it's source code

* Expendable
#+BEGIN_SRC emacs-lisp
  (use-package speed-type)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package command-log-mode)

#+END_SRC
* General Keybindings
** remarks
To enumerate all keybidings in a buffer you do **C-h m**.
A [[https://www.masteringemacs.org/article/mastering-key-bindings-emacs][good article]] on mastering emacs keybindings. When repeating commands
ergonomically, one can chose to create an Hydra (or use magit transient package)
or enable **repeat-mode** (See [[https://karthinks.com/software/it-bears-repeating/][this]] article). I usually get away resting my thumbs
over Ctrl, Alt or Shift keys, but this won't work with prefix keys like C-x or M-g

** prefix keys
- C-x keymap is for global bindings
- C-c are reserved for users
- C-รง are used mainly for my hydras

To se get the list of keybidings belonging to those prefix, type them and then **C-h"
** keybindings
#+NAME: keybindings
#+BEGIN_SRC emacs-lisp
  (repeat-mode) ; calling multiple commands in a keymap without repeating
  (setq repeat-exit-timeout 5) ; in seconds
  ;; shift arrows to move to window x
  (windmove-default-keybindings) ; I loose shift selection, which I don't mind
  (put 'upcase-region 'disabled nil) ; C-x C-u I don't have a capslock key
  (use-package general
    :config
    (general-define-key
     "C-." 'repeat
     "M-x" 'helm-M-x
     "C-x g" 'magit-status
     "C-c p" 'projectile-command-map
     "C-x C-f" 'helm-find-files
     "C-x C-b" 'helm-buffers-list
     "C-:" 'avy-goto-char
     "M-g g" 'avy-goto-line
     "M-g M-g" 'avy-goto-line
     "C-c a" 'org-agenda
     "C-c b" 'helm-bibtex-with-local-bibliography
     "C-c c" 'org-capture
     "C-c e" 'config-visit
     "C-c l" 'org-store-link
     "C-c r" 'config-reload
     ;; "C-." 'er/expand-region       
     "C-c w" 'flyspell-word
     "C-c f" 'flyspell-buffer
     "C-a" 'back-to-indentation
     "C-S-a" 'backward-sentence
     "C-S-e" 'forward-sentence
     "C-M-a" 'beginning-of-defun
     "C-M-e" 'end-of-defun
     ;; killing
     "M-<backspace>" 'delete-indentation ; C-<backspace> kills back word
     "C-<backspace>" 'backward-kill-word ; default
     "C-S-<backspace>" 'kill-whole-line  ; default
     "M-DEL" 'kill-word
     "M-d" 'kill-word                    ; default
     "M-D" 'kill-sexp
     "C-d" 'delete-char                  ; default
     "C-S-d" 'kill-sexp
     "C-M-<backspace>" 'backward-kill-sexp ; default
     ;; changing keybidings due to my new layout "DonTyQ"
     ;; https://configure.zsa.io/ergodox-ez/layouts/RlEeW/latest/0
     ;; "C-b" 'transpose-chars ; never really used transpose chars
     "C-f" 'isearch-forward
     "C-S-f" 'isearch-forward-regexp
     "C-s" 'forward-char
     "C-t" 'backward-char

     ;; s-exp movements
     "C-S-s" 'forward-sexp
     "C-S-t" 'backward-sexp
     "C-M-n" 'forward-list                ; default
     "C-M-p" 'backward-list               ; default
     "C-S-n" 'down-list
     "C-S-p" 'backward-up-list
     ;; marking
     ;;"C-m" 'mark-word ;; rebiding C-m is not so easy because Enter points to it
     ;;"C-S-m" 'mark-sexp

     ;; transposing
     "M-s" 'transpose-words
     "M-t" 'bassavox/transpose-words-backward
     "M-n" 'bassavox/move-line-downward
     "M-p" 'bassavox/move-line-upward
     "M-N" 'transpose-sentences

     "M-S" 'transpose-sexps
     "M-T" 'bassavox/transpose-sexps-backward

     "M-o" 'bassavox/open-line-above
     "C-<prior>" 'previous-buffer
     "C-<next>" 'next-buffer
   
     ; windows
     "C-<dead-tilde>"   'popper-toggle-latest
     "M-<dead-tilde>"   'popper-cycle
     "C-M-<dead-tilde>" 'popper-toggle-type
     )
    (general-define-key
     :keymaps 'isearch-mode-map
     "C-t" 'isearch-repeat-backward)
    ;; (general-create-definer bassavox/leader-key :prefix "C-!")
    (general-create-definer bassavox/leader-key :prefix "C-รง")
    (bassavox/leader-key
      "t" '(:ignore t :which-key "Text")))

  (use-package hydra)
  (defhydra hydra-text-scale (:timeout 4)
    "text zoom"
    ("n" text-scale-increase "in")
    ("t" text-scale-decrease "out")
    ("r" (text-scale-set 0) "reset" :exit t)
    ("f" nil "finished" :exit t))
  (bassavox/leader-key
    "ts" '(hydra-text-scale/body :which-key "scale-text"))
  (bassavox/leader-key
    "p" '(hydra-projectile/body :which-key "projectile"))
  (bassavox/leader-key
    "o" '(hydra-global-org/body :which-key "org-global"))
  (bassavox/leader-key
    "s" '(hydra-smartparens/body :which-key "smartparens"))

#+END_SRC

Trying to keep keybindings in one place
* Dead keys in emacs
  On my ergodox I have dead keys "~" and "^" but also, the respective non dead keys
  counterparts, so I can use keybinds like M-^ (org-delete-identation) and type
  those characters without needing to type a space after them. But for Emacs the
  non dead keys "^" and "~" won't work unless I use this line,
  [[https://www.emacswiki.org/emacs/DeadKeys][as suggested by the wiki]]:
#+BEGIN_SRC  emacs-lisp
(require 'iso-transl)

#+END_SRC
* Custom Functions
:PROPERTIES:
:ORDERED:  t
:END:
Loading this configuration file (binding are defined later):
#+BEGIN_SRC emacs-lisp
  (defun config-visit ()
    (interactive)
    (find-file "~/.emacs.d/config.org"))
#+END_SRC

Reloading this configuration file
#+BEGIN_SRC emacs-lisp
  (defun config-reload ()
    (interactive)
    (org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))
#+END_SRC

The [[https://github.com/bbatsov/crux][Crux]] package has some usefull functions but I'm using a simpler one:
#+begin_src emacs-lisp
  (defun bassavox/open-line-above ()
    (interactive)
    (move-beginning-of-line nil)
    (newline-and-indent)
    (forward-line -1)
    (indent-according-to-mode))
#+end_src

moving lines from [[https://lists.gnu.org/archive/html/help-gnu-emacs/2020-09/msg00276.html][here]]

#+NAME: move-lines
#+begin_src emacs-lisp
  (defun bassavox/move-lines (&optional lines)
    (interactive "*p")
    (let ((lin (line-number-at-pos))
          (col (current-column))
          (num-lines (or lines 1)) )
      (beginning-of-line)
      (let ((line (thing-at-point 'line)))
        (delete-region (point-at-bol) (point-at-eol))
        (delete-char 1)
        (goto-char (point-min))
        (forward-line (+ lin num-lines -1))
        (insert line)
        (forward-line -1)
        (beginning-of-line)
        (forward-char col) )))


  (defun bassavox/move-line-downward (&optional lines)
    (interactive "*p")
    (bassavox/move-lines lines))

  (defun bassavox/move-line-upward (&optional lines)
    (interactive "*p")
    (bassavox/move-lines (- lines)))
#+end_src

#+NAME: transpose-word-backward
#+begin_src emacs-lisp
  (defun bassavox/transpose-words-backward (&optional ARG)
    (interactive "*p")
    (transpose-words (- ARG)))
    
#+end_src

#+NAME: bassavox/transpose-sexps-backward
#+begin_src emacs-lisp
  (defun bassavox/transpose-sexps-backward(&optional ARG)
    (interactive "*p")
    (transpose-sexps (- ARG)))
  
#+end_src

* Next Steps
  Here goes the list of packages I want to try out someday:
** Forge
   [[https://emacsair.me/2018/12/19/forge-0.1/][link]]
   Integrating gitlab or github API
   
** org-wild-notifier
   Getting  notification integration for org-agenda views.
   [[https://github.com/akhramov/org-wild-notifier.el][github]]
** declarative org capture templates
   Easier syntax for Org Capture
   [[https://github.com/progfolio/doct][github]]
** better search keybindings
   [[https://www.emacswiki.org/emacs/IncrementalSearch][See emacs wiki]]
** better resizing windows, like text resizing
